## API Report File for "@3d-tiles-tools/tools"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />
/// <reference types="tools/@types/gltf-pipeline/index.js" />
/// <reference types="tools/@types/gltfpack/index.js" />

import { Accessor } from '@gltf-transform/core';
import { BatchTable } from '@3d-tiles-tools/structure';
import { BinaryPropertyTable } from '@3d-tiles-tools/metadata';
import { BoundingVolume } from '@3d-tiles-tools/structure';
import { ClassProperty } from '@3d-tiles-tools/structure';
import { ContentData } from '@3d-tiles-tools/base';
import { Document } from '@gltf-transform/core';
import { EXTStructuralMetadata } from '@3d-tiles-tools/gltf-extensions';
import { KtxEtc1sOptions } from '@3d-tiles-tools/ktx';
import { KtxUastcOptions } from '@3d-tiles-tools/ktx';
import { MeshFeaturesFeatureId } from '@3d-tiles-tools/gltf-extensions';
import { NodeIO } from '@gltf-transform/core';
import { PntsFeatureTable } from '@3d-tiles-tools/structure';
import { Primitive } from '@gltf-transform/core';
import { PropertyModel } from '@3d-tiles-tools/metadata';
import { PropertyTableModel } from '@3d-tiles-tools/metadata';
import { Schema } from '@3d-tiles-tools/structure';
import { StructuralMetadataPropertyTable } from '@3d-tiles-tools/gltf-extensions';
import { Tile } from '@3d-tiles-tools/structure';
import { Tileset } from '@3d-tiles-tools/structure';
import { TilesetEntry } from '@3d-tiles-tools/tilesets';
import { TilesetSource } from '@3d-tiles-tools/tilesets';
import { TilesetTarget } from '@3d-tiles-tools/tilesets';
import { Transform } from '@gltf-transform/core';
import { TraversalCallback } from '@3d-tiles-tools/tilesets';
import { TypedArray } from '@gltf-transform/core';

// @internal
export class AccessorCreation {
    static createAccessorArray(componentType: string, accessorValues: Iterable<number>): TypedArray;
    static createAccessorFromProperty(document: Document, classProperty: ClassProperty, propertyModel: PropertyModel, numRows: number): Accessor;
    static createAccessorFromValues(document: Document, classProperty: ClassProperty, accessorValues: Iterable<number>): Accessor;
    static createAccessorValues(classProperty: ClassProperty, propertyModel: PropertyModel, numRows: number): Iterable<number>;
}

// @internal
export type AttributeInfo = {
    componentsPerAttribute: number;
    componentDatatype: string;
    byteOffset: number;
    byteStride: number;
    normalized: boolean;
    quantization?: QuantizationInfo;
};

// @internal
export class BasicTilesetProcessor extends TilesetProcessor {
    constructor(processExternalTilesets?: boolean);
    end(): Promise<void>;
    forEachExplicitTile(callback: (tile: Tile) => Promise<void>): Promise<void>;
    forEachTile(callback: TraversalCallback): Promise<void>;
    forTileset(callback: (tileset: Tileset, schema: Schema | undefined) => Promise<Tileset>): Promise<void>;
    processAllEntries(entryProcessor: TilesetEntryProcessor): Promise<void>;
    processTileContentEntries(uriProcessor: (uri: string) => string, entryProcessor: TilesetEntryProcessor): Promise<void>;
    static updateTileContent(tile: Tile, contentUris: string[]): void;
}

// @internal
export class BatchTableClassProperties {
    static createClassProperty(batchTablePropertyName: string, batchTablePropertyValue: any): ClassProperty;
}

// @internal
export class BatchTablePropertyTableModels {
    static create(table: {
        [key: string]: any;
    }, binary: Buffer, externalProperties: {
        [key: string]: PropertyModel;
    }, numRows: number): PropertyTableModel;
}

// @internal
export class BatchTableSchemas {
    static createSchema(identifier: string, batchTable: BatchTable): Schema | undefined;
}

// @internal
export class BoundingVolumes {
    static computeBoundingVolumeBoxCorners(boundingVolumeBox: number[]): number[][];
    static computeBoundingVolumeBoxFromBoundingVolume(boundingVolume: BoundingVolume): number[] | undefined;
    static computeUnionBoundingVolumeBox(boundingVolumeBoxes: Iterable<number[]>): number[];
    static createBoundingVolumeBoxFromMinMax(min: number[], max: number[]): number[];
    static createBoundingVolumeBoxFromPoints(points: number[][]): number[];
    static createUnitCubeBoundingVolumeBox(): number[];
    static transformBoundingVolumeBox(boundingVolumeBox: number[], transform: number[]): number[];
    static translateBoundingVolumeBox(boundingVolumeBox: number[], translation: number[]): number[];
}

// @internal
export class ComponentDatatype {
    static readonly BYTE = 5120;
    static readonly DOUBLE = 5130;
    static readonly FLOAT = 5126;
    static fromTypedArray(array: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array): number;
    static getSizeInBytes(componentDatatype: number): number;
    static readonly INT = 5124;
    static readonly SHORT = 5122;
    static toString(componentDatatype: number): "BYTE" | "UNSIGNED_BYTE" | "SHORT" | "UNSIGNED_SHORT" | "INT" | "UNSIGNED_INT" | "FLOAT" | "DOUBLE";
    static readonly UNSIGNED_BYTE = 5121;
    static readonly UNSIGNED_INT = 5125;
    static readonly UNSIGNED_SHORT = 5123;
}

// @internal
export class ContentError extends Error {
    constructor(message: string);
    // (undocumented)
    toString: () => string;
}

// @internal
export class ContentOps {
    static b3dmToGlbBuffer(inputBuffer: Buffer): Buffer;
    static cmptToGlbBuffers(inputBuffer: Buffer, externalGlbResolver: (glbUri: string) => Promise<Buffer | undefined>): Promise<Buffer[]>;
    static glbToB3dmBuffer(inputBuffer: Buffer): Buffer;
    static glbToI3dmBuffer(inputBuffer: Buffer): Buffer;
    static i3dmToGlbBuffer(inputBuffer: Buffer): Buffer;
    static optimizeB3dmBuffer(inputBuffer: Buffer, options: any): Promise<Buffer>;
    static optimizeI3dmBuffer(inputBuffer: Buffer, options: any): Promise<Buffer>;
}

// @internal
export interface ContentStage extends Stage {
    options?: any;
}

// @internal
export class ContentStageExecutor {
    static executeContentStage(contentStage: ContentStage, tilesetProcessor: BasicTilesetProcessor): Promise<void>;
}

// @internal
export class ContentStages {
    static readonly CONTENT_STAGE_B3DM_TO_GLB = "b3dmToGlb";
    static readonly CONTENT_STAGE_CONVERT_B3DM_TO_GLB = "convertB3dmToGlb";
    static readonly CONTENT_STAGE_CONVERT_PNTS_TO_GLB = "convertPntsToGlb";
    static readonly CONTENT_STAGE_GLB_TO_B3DM = "glbToB3dm";
    static readonly CONTENT_STAGE_GLB_TO_I3DM = "glbToI3dm";
    static readonly CONTENT_STAGE_I3DM_TO_GLB = "i3dmToGlb";
    static readonly CONTENT_STAGE_OPTIMIZE_B3DM = "optimizeB3dm";
    static readonly CONTENT_STAGE_OPTIMIZE_GLB = "optimizeGlb";
    static readonly CONTENT_STAGE_OPTIMIZE_I3DM = "optimizeI3dm";
    static readonly CONTENT_STAGE_SEPARATE_GLTF = "separateGltf";
    static createB3dmToGlb(): ContentStage;
    static createContentStage(contentStageJson: any): ContentStage;
    static createConvertB3dmToGlb(): ContentStage;
    static createConvertPntsToGlb(): ContentStage;
    static createGlbToB3dm(): ContentStage;
    static createGlbToI3dm(): ContentStage;
    static createI3dmToGlb(): ContentStage;
    static createOptimizeB3dm(options: any): ContentStage;
    static createOptimizeGlb(options: any): ContentStage;
    static createOptimizeI3dm(options: any): ContentStage;
    static createSeparateGltf(): ContentStage;
}

// @internal
export class ContentUpgrades {
    static upgradeB3dmGltf1ToGltf2(inputBuffer: Buffer, options: any): Promise<Buffer>;
    static upgradeI3dmGltf1ToGltf2(inputBuffer: Buffer, options: any): Promise<Buffer>;
}

// @internal
export class DefaultPointCloud implements ReadablePointCloud {
    addAttribute(name: string, type: string, componentType: string, attribute: Iterable<number>): void;
    getAttributeComponentType(name: string): string | undefined;
    getAttributes(): string[];
    getAttributeType(name: string): string | undefined;
    getAttributeValues(name: string): Iterable<number> | undefined;
    getGlobalPosition(): [number, number, number] | undefined;
    getNormalizedLinearColors(): Iterable<number[]> | undefined;
    getNormalizedLinearGlobalColor(): [number, number, number, number] | undefined;
    getNormals(): Iterable<number[]> | undefined;
    getPositions(): Iterable<number[]>;
    // (undocumented)
    setGlobalPosition(globalPosition: [number, number, number] | undefined): void;
    setNormalizedLinearColors(colors: Iterable<number[]>): void;
    // (undocumented)
    setNormalizedLinearGlobalColor(globalColor: [number, number, number, number] | undefined): void;
    setNormals(normals: Iterable<number[]>): void;
    setPositions(positions: Iterable<number[]>): void;
}

// @internal
export class DracoDecoder {
    static create(): Promise<DracoDecoder>;
    decodePointCloud(properties: {
        [key: string]: number;
    }, binary: Buffer): DracoDecoderResult;
}

// @internal
export type DracoDecoderResult = {
    [key: string]: {
        attributeData: Buffer;
        attributeInfo: AttributeInfo;
    };
};

// @internal
export class DracoError extends Error {
    constructor(message: string);
    // (undocumented)
    toString: () => string;
}

// @internal
export class GltfPack {
    static process(inputGlb: Buffer, options: GltfPackOptions): Promise<Buffer>;
}

// @internal
export type GltfPackOptions = Partial<{
    c: boolean;
    cc: boolean;
    si: number;
    sa: boolean;
    slb: boolean;
    vp: number;
    vt: number;
    vn: number;
    vc: number;
    vpi: boolean;
    vpn: boolean;
    vpf: boolean;
    at: number;
    ar: number;
    as: number;
    af: number;
    ac: boolean;
    kn: boolean;
    km: boolean;
    ke: boolean;
    mm: boolean;
    mi: boolean;
    cf: boolean;
    noq: boolean;
}>;

// @internal
export class GltfPipelineLegacy {
    // (undocumented)
    static process(gltf: any): Promise<void>;
}

// @internal
export class GltfTransform {
    static getIO(): Promise<NodeIO>;
    static process(inputGlb: Buffer, ...transforms: Transform[]): Promise<Buffer>;
}

// @internal
export interface GltfTransformPointCloud {
    document: Document;
    primitive: Primitive;
}

// @internal
export class GltfTransformPointClouds {
    static applyQuantization(document: Document, quantizePositions: boolean, quantizeNormals: boolean): Promise<void>;
    static build(readablePointCloud: ReadablePointCloud, mayRequireAlpha: boolean): GltfTransformPointCloud;
}

// @internal
export class GltfTransformTextures {
    static createTransformTexturesToKtx(etc1sOptions: KtxEtc1sOptions, uastcOptions: KtxUastcOptions): Transform;
}

// @internal
export class GltfUtilities {
    static extractDataFromGlb(glbBuffer: Buffer): {
        jsonData: Buffer;
        binData: Buffer;
    };
    static extractJsonFromGlb(glbBuffer: Buffer): Buffer;
    static getGltfVersion(glbBuffer: Buffer): number;
    static optimizeGlb(glbBuffer: Buffer, options: any): Promise<Buffer>;
    static replaceCesiumRtcExtension(glbBuffer: Buffer): Promise<Buffer>;
    static upgradeGlb(glbBuffer: Buffer, options: any): Promise<Buffer>;
}

// @internal
export class Ids {
    static sanitize(identifier: string): string;
}

// @internal
export class InstanceFeaturesUtils {
    static createInstanceFeaturesInfoString(document: Document): string;
}

// @internal
export class MeshFeaturesUtils {
    static createMeshFeaturesInfoString(document: Document): string;
}

// @internal
export class NumberTypeDescriptions {
    static computeComponentType(value: number | bigint | number[] | bigint[] | number[][] | bigint[][]): string;
}

// @internal
export interface Pipeline {
    input: string;
    output: string;
    tilesetStages: TilesetStage[];
}

// @internal
export class PipelineError extends Error {
    constructor(message: string);
    // (undocumented)
    toString: () => string;
}

// @internal
export class PipelineExecutor {
    static executePipeline(pipeline: Pipeline, overwrite: boolean): Promise<void>;
    static setTempBaseDirectory(directory: string | undefined): void;
}

// @internal
export class Pipelines {
    static createPipeline(pipelineJson: any): Pipeline;
}

// @internal
export class PntsPointClouds {
    static create(featureTable: PntsFeatureTable, featureTableBinary: Buffer, batchTable: BatchTable): Promise<ReadablePointCloud>;
    static hasOctEncodedNormals(featureTable: PntsFeatureTable): boolean;
    static hasQuantizedPositions(featureTable: PntsFeatureTable): boolean;
    static mayRequireAlpha(featureTable: PntsFeatureTable): boolean;
}

// @internal
export type QuantizationInfo = {
    quantizationBits: number;
    minValues?: number[];
    range?: number;
    octEncoded: boolean;
};

// @internal
export interface ReadablePointCloud {
    getAttributeComponentType(name: string): string | undefined;
    getAttributes(): string[];
    getAttributeType(name: string): string | undefined;
    getAttributeValues(name: string): Iterable<number> | undefined;
    getGlobalPosition(): [number, number, number] | undefined;
    getNormalizedLinearColors(): Iterable<number[]> | undefined;
    getNormalizedLinearGlobalColor(): [number, number, number, number] | undefined;
    getNormals(): Iterable<number[]> | undefined;
    getPositions(): Iterable<number[]>;
}

// @internal
export interface Stage {
    description?: string;
    name: string;
}

// @internal
export class StringBuilder {
    constructor();
    // (undocumented)
    addLine(...args: any[]): void;
    // (undocumented)
    decreaseIndent(): void;
    // (undocumented)
    increaseIndent(): void;
    // (undocumented)
    toString(): string;
}

// @internal
export class StructuralMetadataPropertyTables {
    static create(extStructuralMetadata: EXTStructuralMetadata, binaryPropertyTable: BinaryPropertyTable): StructuralMetadataPropertyTable;
}

// @internal
export class StructuralMetadataUtils {
    static createStructuralMetadataInfoString(document: Document): string;
}

// @internal
export class TileContentProcessing {
    static process(tilesetSourceName: string, tilesetTargetName: string, overwrite: boolean, tileContentProcessor: TileContentProcessor): Promise<void>;
}

// @internal
export type TileContentProcessor = (content: Buffer, type: string | undefined) => Promise<Buffer>;

// @internal
export class TileContentProcessors {
    static concat(...tileContentProcessors: TileContentProcessor[]): TileContentProcessor;
}

// @internal
export class TileContentProcessorsGltfpack {
    static create(options: GltfPackOptions): TileContentProcessor;
}

// @internal
export class TileContentProcessorsGltfPipeline {
    static create(options: any): TileContentProcessor;
}

// @internal
export class TileContentProcessorsGltfTransform {
    static create(...transforms: Transform[]): TileContentProcessor;
}

// @internal
export class TileContentProcessorsTextures {
    static encodeToKtx(etc1sOptions: KtxEtc1sOptions, uastcOptions: KtxUastcOptions): TileContentProcessor;
}

// @internal
export class TileFormatsMigration {
    static applyRtcCenter(document: Document, rtcCenter: number[]): void;
    static convertB3dmToGlb(b3dmBuffer: Buffer): Promise<Buffer>;
    static convertI3dmToGlb(i3dmBuffer: Buffer, externalGlbResolver: (uri: string) => Promise<Buffer | undefined>): Promise<Buffer>;
    static convertPntsToGlb(pntsBuffer: Buffer): Promise<Buffer>;
    // (undocumented)
    static readonly DEBUG_LOG_FILE_CONTENT = false;
    static makeSingleRoot(document: Document): void;
}

// @internal
export class TileFormatsMigrationB3dm {
    static convertB3dmToGlb(b3dmBuffer: Buffer): Promise<Buffer>;
}

// @internal
export class TileFormatsMigrationI3dm {
    static convertI3dmToGlb(i3dmBuffer: Buffer, externalGlbResolver: (uri: string) => Promise<Buffer | undefined>): Promise<Buffer>;
}

// @internal
export class TileFormatsMigrationPnts {
    static convertPntsToGlb(pntsBuffer: Buffer): Promise<Buffer>;
}

// @internal
export class TilesetCombiner {
    constructor(externalTilesetDetector: (contentData: ContentData) => Promise<boolean>);
    combine(tilesetSourceName: string, tilesetTargetName: string, overwrite: boolean): Promise<void>;
}

// @internal
export class TilesetConverter {
    static convert(input: string, inputTilesetJsonFileName: string | undefined, output: string, force: boolean): Promise<void>;
}

// @internal
export class TilesetDataProcessor extends TilesetProcessor {
    processAllEntries(entryProcessor: TilesetEntryProcessor): Promise<void>;
}

// @internal
export type TilesetEntryProcessor = (sourceEntry: TilesetEntry, type: string | undefined) => Promise<TilesetEntry | undefined>;

// @internal
export class TilesetJsonCreator {
    static createTilesetFromContents(baseDir: string, contentUris: string[]): Promise<Tileset>;
}

// @internal
export class TilesetMerger {
    constructor();
    merge(tilesetSourceNames: string[], tilesetTargetName: string, overwrite: boolean): Promise<void>;
}

// @internal
export class TilesetObjectUpgrader {
    constructor(upgradeOptions: TilesetUpgradeOptions);
    upgradeTilesetObject(tileset: Tileset): Promise<void>;
}

// @internal
export class TilesetOperations {
    static combine(tilesetSourceName: string, tilesetTargetName: string, overwrite: boolean): Promise<void>;
    static merge(tilesetSourceNames: string[], tilesetTargetName: string, overwrite: boolean): Promise<void>;
    static upgrade(tilesetSourceName: string, tilesetTargetName: string, overwrite: boolean, targetVersion: string, gltfUpgradeOptions: any): Promise<void>;
    static upgradeTileset(tileset: Tileset, targetVersion: string): Promise<void>;
}

// @internal
export class TilesetProcessing {
    static getSourceValue(tilesetSource: TilesetSource, key: string): Buffer;
    static parseSourceValue<T>(tilesetSource: TilesetSource, key: string): T;
    static resolveSchema(tilesetSource: TilesetSource, tileset: Tileset): Schema | undefined;
}

// @internal
export abstract class TilesetProcessor {
    begin(tilesetSourceName: string, tilesetTargetName: string, overwrite: boolean): Promise<void>;
    end(): Promise<void>;
    fetchSourceEntry(key: string): Promise<TilesetEntry | undefined>;
    protected getContext(): TilesetProcessorContext;
    protected getTargetKey(sourceKey: string): string | undefined;
    isProcessed(key: string): boolean;
    markAsProcessed(key: string): void;
    protected processAllEntriesInternal(entryProcessor: TilesetEntryProcessor): Promise<void>;
    processEntry(sourceKey: string, entryProcessor: TilesetEntryProcessor): Promise<void>;
    protected putTargetKey(sourceKey: string, targetKey: string): void;
    storeTargetEntries(...targetEntries: TilesetEntry[]): void;
}

// @internal
export interface TilesetProcessorContext {
    processedKeys: {
        [key: string]: boolean;
    };
    schema: Schema | undefined;
    sourceTileset: Tileset;
    targetKeys: {
        [key: string]: string;
    };
    targetTileset: Tileset;
    tilesetSource: TilesetSource;
    tilesetSourceJsonFileName: string;
    tilesetTarget: TilesetTarget;
    tilesetTargetJsonFileName: string;
}

// @internal
export class TilesetProcessorContexts {
    static close(context: TilesetProcessorContext): Promise<void>;
    static create(tilesetSourceName: string, tilesetTargetName: string, overwrite: boolean): Promise<TilesetProcessorContext>;
}

// @internal
export interface TilesetStage extends Stage {
    contentStages?: ContentStage[];
    excludedContentTypes?: string[];
    includedContentTypes?: string[];
}

// @internal
export class TilesetStageExecutor {
    static executeTilesetStage(tilesetStage: TilesetStage, currentInput: string, currentOutput: string, overwrite: boolean): Promise<void>;
}

// @internal
export class TilesetStages {
    static create(name: string, description: string, contentStages: ContentStage[]): TilesetStage;
    static createCombine(): TilesetStage;
    static createGzip(includedContentTypes: string[] | undefined): TilesetStage;
    static createTilesetStage(tilesetStageJson: any): TilesetStage;
    static createUngzip(): ContentStage;
    static createUpgrade(): TilesetStage;
    static readonly TILESET_STAGE_COMBINE = "combine";
    static readonly TILESET_STAGE_GZIP = "gzip";
    static readonly TILESET_STAGE_UNGZIP = "ungzip";
    static readonly TILESET_STAGE_UPGRADE = "upgrade";
}

// @internal
export type TilesetUpgradeOptions = {
    upgradeExternalTilesets: boolean;
    upgradedAssetVersionNumber: string;
    upgradeRefineCase: boolean;
    upgradeContentUrlToUri: boolean;
    upgradeEmptyChildrenToUndefined: true;
    upgradeContentGltfExtensionDeclarations: boolean;
    upgradeB3dmGltf1ToGltf2: boolean;
    upgradeI3dmGltf1ToGltf2: boolean;
    upgradePntsToGlb: boolean;
    upgradeB3dmToGlb: boolean;
    upgradeI3dmToGlb: boolean;
};

// @internal
export class TilesetUpgrader {
    constructor(targetVersion: string, gltfUpgradeOptions: any);
    upgrade(tilesetSourceName: string, tilesetTargetName: string, overwrite: boolean): Promise<void>;
    upgradeTileset(tileset: Tileset): Promise<void>;
}

// @internal
export class TileTableDataToMeshFeatures {
    static convertBatchIdToMeshFeatures(document: Document, primitive: Primitive): MeshFeaturesFeatureId;
}

// @internal
export class TileTableDataToStructuralMetadata {
    static assignPerPointProperties(document: Document, primitive: Primitive, batchTable: BatchTable, batchTableBinary: Buffer, externalProperties: {
        [key: string]: PropertyModel;
    }, numRows: number): void;
    static convertBatchTableToPropertyTable(document: Document, batchTable: BatchTable, batchTableBinary: Buffer, numRows: number): StructuralMetadataPropertyTable | undefined;
}

// @internal
export class TypeDetection {
    static computeCommonArrayLegth(value: any[][]): number | undefined;
    static computeCommonComponentType(array: number[] | bigint[] | number[][] | bigint[][]): string;
    static computeCommonType(array: any[]): string | undefined;
    static containsOnlyArrays(value: any[]): boolean;
}

// (No @packageDocumentation comment for this package)

```
