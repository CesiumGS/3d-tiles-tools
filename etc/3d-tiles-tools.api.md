## API Report File for "3d-tiles-tools"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { PathLike } from 'fs';

// @internal (undocumented)
export class ArchiveFunctions3tz {
    // (undocumented)
    static md5LessThan(md5hashA: Buffer, md5hashB: Buffer): boolean;
    // (undocumented)
    static readEntry(fd: number, zipIndex: IndexEntry[], path: string): {
        compression_method: number;
        data: Buffer;
    } | undefined;
    // (undocumented)
    static readFileName(fd: number, offset: number | bigint): string;
    // (undocumented)
    static readZipIndex(fd: number): IndexEntry[];
    // (undocumented)
    static zipIndexFind(zipIndex: IndexEntry[], searchHash: Buffer): number;
}

// @internal
export class ArrayValues {
    static anyDeepGreaterThan(a: any, b: any): boolean;
    static anyDeepLessThan(a: any, b: any): boolean;
    static deepAdd(value: any, addend: any): any;
    static deepClone(value: any): any;
    static deepEquals(a: any, b: any): boolean;
    static deepMax(a: any, b: any): any;
    static deepMin(a: any, b: any): any;
    static deepMultiply(value: any, factor: any): any;
}

// @internal
export interface Asset extends RootProperty {
    tilesetVersion?: string;
    version: string;
}

// @internal
export interface Availability extends RootProperty {
    availableCount?: number;
    bitstream?: number;
    constant?: number;
}

// @internal
export interface AvailabilityInfo {
    isAvailable(index: number): boolean;
    get length(): number;
}

// @internal
export class AvailabilityInfos {
    static createChildSubtree(availability: Availability, bufferViewDatas: Buffer[], implicitTiling: TileImplicitTiling): AvailabilityInfo;
    static createTileOrContent(availability: Availability, bufferViewDatas: Buffer[], implicitTiling: TileImplicitTiling): AvailabilityInfo;
}

// @internal
export interface BinaryBufferData {
    buffersData: Buffer[];
    bufferViewsData: Buffer[];
}

// @internal
export class BinaryBufferDataResolver {
    static resolve(binaryBufferStructure: BinaryBufferStructure, binaryBuffer: Buffer | undefined, resourceResolver: ResourceResolver): Promise<BinaryBufferData>;
}

// @internal
export class BinaryBuffers {
    static createBinaryBufferStructure(binaryBufferData: BinaryBufferData, newBufferViewsData: Buffer[]): BinaryBufferStructure;
}

// @internal
export interface BinaryBufferStructure {
    // (undocumented)
    buffers: BufferObject[];
    // (undocumented)
    bufferViews: BufferView[];
}

// @internal
export class BinaryDataError extends Error {
    constructor(message: string);
    // (undocumented)
    toString: () => string;
}

// @internal
export interface BinaryEnumInfo {
    enumValueNameValues: {
        [key: string]: {
            [key: string]: number;
        };
    };
    enumValueTypes: {
        [key: string]: string;
    };
}

// @internal
export interface BinaryPropertyTable {
    binaryBufferData: BinaryBufferData;
    binaryBufferStructure: BinaryBufferStructure;
    binaryEnumInfo: BinaryEnumInfo;
    metadataClass: MetadataClass;
    propertyTable: PropertyTable;
}

// @internal
export class BinaryPropertyTableModel implements PropertyTableModel {
    constructor(binaryPropertyTable: BinaryPropertyTable);
    getClassProperty(propertyId: string): ClassProperty | undefined;
    // (undocumented)
    getCount(): number;
    getMetadataEntityModel(index: number): MetadataEntityModel;
    getPropertyModel(propertyId: string): PropertyModel | undefined;
    // (undocumented)
    getPropertyNames(): string[];
    getPropertyTableProperty(propertyId: string): PropertyTableProperty | undefined;
}

// @internal
export class BinaryPropertyTables {
    static createBinaryPropertyTable(schema: Schema, className: string, propertyName: string, values: any, arrayOffsetType: string | undefined, stringOffsetType: string | undefined): BinaryPropertyTable;
    static createBinaryPropertyTableFromProperty(propertyName: string, classProperty: ClassProperty, values: any, arrayOffsetType: string | undefined, stringOffsetType: string | undefined, metadataEnum: MetadataEnum | undefined): BinaryPropertyTable;
    static createPropertyTableProperty(classProperty: ClassProperty, schema: Schema, values: any, arrayOffsetType: string | undefined, stringOffsetType: string | undefined, bufferViewsData: Buffer[]): PropertyTableProperty;
    static createSchemaFromClassProperty(propertyName: string, classProperty: ClassProperty, metadataEnum: MetadataEnum | undefined): Schema;
}

// @internal
export interface BinarySubtreeData {
    binaryBufferData: BinaryBufferData;
    binaryBufferStructure: BinaryBufferStructure;
    subtree: Subtree;
}

// @internal
export class BinarySubtreeDataResolver {
    static resolveFromBuffer(input: Buffer, resourceResolver: ResourceResolver): Promise<BinarySubtreeData>;
    static resolveFromJson(subtree: Subtree, resourceResolver: ResourceResolver): Promise<BinarySubtreeData>;
    static resolveInternal(subtree: Subtree, binaryBuffer: Buffer | undefined, resourceResolver: ResourceResolver): Promise<BinarySubtreeData>;
}

// @internal
export interface BoundingVolume extends RootProperty {
    box?: number[];
    region?: number[];
    sphere?: number[];
}

// @internal
export interface BufferObject extends RootProperty {
    byteLength: number;
    name?: string;
    uri?: string;
}

// @internal
export class Buffers {
    static createBinaryString(buffer: Buffer): string;
    static fromTypedArray(array: Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array): Buffer;
    static getBufferPadded(buffer: Buffer, byteOffset?: number): Buffer;
    static getJson(buffer: Buffer): any;
    static getJsonBufferPadded(json: any, byteOffset?: number): Buffer;
    static getMagicBytes(buffer: Buffer, byteOffset: number, byteLength: number): Buffer;
    static getMagicString(buffer: Buffer, byteOffset?: number): string;
    static getUnicodeBOMDescription(buffer: Buffer): string | undefined;
    static gunzip(inputBuffer: Buffer): Buffer;
    static gzip(inputBuffer: Buffer): Buffer;
    static isGzipped(buffer: Buffer): boolean;
    static isProbablyJson(buffer: Buffer): boolean;
}

// @internal
export interface BufferView extends RootProperty {
    buffer: number;
    byteLength: number;
    byteOffset: number;
    name?: string;
}

// @internal
export class ClassProperties {
    static hasEffectivelyFloatingPointType(property: ClassProperty): boolean;
    static hasNumericType(property: ClassProperty): boolean;
}

// @internal
export interface ClassProperty extends RootProperty {
    array?: boolean;
    componentType?: string;
    count?: number;
    default?: any;
    description?: string;
    enumType?: string;
    max?: any;
    min?: any;
    name?: string;
    noData?: any;
    normalized?: boolean;
    offset?: any;
    required?: boolean;
    scale?: any;
    semantic?: string;
    type: string;
}

// @internal
export interface Content extends RootProperty {
    boundingVolume?: BoundingVolume;
    group?: number;
    metadata?: MetadataEntity;
    uri: string;
}

// @internal
export interface ContentData {
    exists(): Promise<boolean>;
    get extension(): string;
    getData(): Promise<Buffer | null>;
    getMagic(): Promise<Buffer>;
    getParsedObject(): Promise<any>;
    get uri(): string;
}

// @internal
export class ContentDataTypeRegistry {
    static findContentDataType(contentData: ContentData): Promise<string | undefined>;
    static findType(uri: string, data: Buffer): Promise<string | undefined>;
}

// @internal
export class DefaultMetadataEntityModel implements MetadataEntityModel {
    constructor(metadataClass: MetadataClass, semanticToPropertyId: {
        [key: string]: string;
    }, json: any);
    getPropertyValue(propertyId: string): any;
    getPropertyValueBySemantic(semantic: string): any;
}

// @internal
export function defaultValue<T>(a: T | undefined, b: T): T;

// @internal
export function defined<T>(value: T): value is NonNullable<T>;

// @internal
export class DeveloperError extends Error {
    constructor(message: string);
    // (undocumented)
    toString: () => string;
}

// @internal
export interface EnumValue extends RootProperty {
    description?: string;
    name: string;
    value: number;
}

// @internal
export class ExplicitTraversedTile implements TraversedTile {
    constructor(tile: Tile, path: string, level: number, parent: TraversedTile | undefined, schema: Schema | undefined, resourceResolver: ResourceResolver);
    asFinalTile(): Tile;
    asRawTile(): Tile;
    static createRoot(root: Tile, schema: Schema | undefined, resourceResolver: ResourceResolver): TraversedTile;
    getChildren(): Promise<TraversedTile[]>;
    getFinalContents(): Content[];
    getImplicitTiling(): TileImplicitTiling | undefined;
    getMetadata(): MetadataEntity | undefined;
    getParent(): TraversedTile | undefined;
    getRawContents(): Content[];
    getResourceResolver(): ResourceResolver;
    getSubtreeUri(): string | undefined;
    isImplicitTilesetRoot(): boolean;
    get level(): number;
    get path(): string;
    toString: () => string;
}

// @internal
export class ExplicitTraversedTiles {
    static createTraversedChildren(implicitTiling: TileImplicitTiling, schema: Schema | undefined, parent: ExplicitTraversedTile, resourceResolver: ResourceResolver): Promise<TraversedTile[]>;
}

// @internal
export class FileResourceResolver implements ResourceResolver {
    constructor(basePath: string);
    derive(uri: string): ResourceResolver;
    resolveData(uri: string): Promise<Buffer | null>;
    resolveDataPartial(uri: string, maxBytes: number): Promise<Buffer | null>;
}

// @internal
export interface Group extends MetadataEntity {
}

// @internal
export class ImplicitTilingError extends Error {
    constructor(message: string);
    // (undocumented)
    toString: () => string;
}

// @internal
export class ImplicitTilings {
    static computeNumberOfNodesInLevel(implicitTiling: TileImplicitTiling, level: number): number;
    static computeNumberOfNodesPerSubtree(implicitTiling: TileImplicitTiling): number;
    static createRootCoordinates(implicitTiling: TileImplicitTiling): TreeCoordinates;
    static createString(coordinates: TreeCoordinates): string;
    static createSubtreeCoordinatesIterator(implicitTiling: TileImplicitTiling): Iterable<TreeCoordinates>;
    static globalizeCoordinates(implicitTiling: TileImplicitTiling, rootCoordinates: TreeCoordinates, coordinates: TreeCoordinates): TreeCoordinates;
    static substituteTemplateUri(subdivisionScheme: string, templateUri: string, coordinates: TreeCoordinates): string;
}

// @internal
export class ImplicitTraversedTile implements TraversedTile {
    constructor(implicitTiling: TileImplicitTiling, resourceResolver: ResourceResolver, root: TraversedTile, path: string, subtreeModel: SubtreeModel, globalLevel: number, globalCoordinate: TreeCoordinates, rootCoordinate: TreeCoordinates, localCoordinate: TreeCoordinates, parent: TraversedTile);
    asFinalTile(): Tile;
    asRawTile(): Tile;
    getChildren(): Promise<TraversedTile[]>;
    getFinalContents(): Content[];
    getGlobalCoordinate(): TreeCoordinates;
    getLocalCoordinate(): TreeCoordinates;
    getParent(): TraversedTile | undefined;
    getRawContents(): Content[];
    getResourceResolver(): ResourceResolver;
    getSubtreeUri(): string | undefined;
    isImplicitTilesetRoot(): boolean;
    get level(): number;
    get path(): string;
    toString: () => string;
}

// @internal
export class IndexBuilder {
    constructor();
    addEntry(key: string, size: number): void;
    createBuffer(): Buffer;
}

// @internal
export interface IndexBuilderEntry {
    key: string;
    offset: bigint;
}

// @internal
export interface IndexEntry {
    hash: Buffer;
    offset: bigint;
}

// @internal
export class Iterables {
    static filter<T>(iterable: Iterable<T>, include: (element: T) => boolean): Iterable<T>;
    static filterWIthIndex<T>(iterable: Iterable<T>, include: (element: T, index: number) => boolean): Iterable<T>;
    static flatten<T>(iterable: Iterable<T[]>): Iterable<T>;
    static map<S, T>(iterable: Iterable<S>, mapper: (element: S) => T): Iterable<T>;
    static overFiles(directory: string | PathLike, recurse: boolean): Iterable<string>;
    static segmentize<T>(iterable: Iterable<T>, segmentSize: number): Iterable<T[]>;
}

// @internal
export class LazyContentData implements ContentData {
    constructor(uri: string, resourceResolver: ResourceResolver);
    exists(): Promise<boolean>;
    get extension(): string;
    getData(): Promise<Buffer | null>;
    getMagic(): Promise<Buffer>;
    getParsedObject(): Promise<any>;
    get uri(): string;
}

// @internal
export interface MetadataClass extends RootProperty {
    description?: string;
    name?: string;
    properties?: {
        [key: string]: ClassProperty;
    };
}

// @internal
export class MetadataComponentTypes {
    static allComponentTypes: string[];
    static byteSizeForComponentType(componentType: string): number;
    // (undocumented)
    static readonly FLOAT32 = "FLOAT32";
    // (undocumented)
    static readonly FLOAT64 = "FLOAT64";
    // (undocumented)
    static readonly INT16 = "INT16";
    // (undocumented)
    static readonly INT32 = "INT32";
    // (undocumented)
    static readonly INT64 = "INT64";
    // (undocumented)
    static readonly INT8 = "INT8";
    static integerComponentTypes: string[];
    static isIntegerComponentType(componentType: string | undefined): boolean;
    static isUnsignedComponentType(componentType: string | undefined): boolean;
    // (undocumented)
    static normalize(value: number, componentType: string | undefined): number;
    // (undocumented)
    static readonly UINT16 = "UINT16";
    // (undocumented)
    static readonly UINT32 = "UINT32";
    // (undocumented)
    static readonly UINT64 = "UINT64";
    // (undocumented)
    static readonly UINT8 = "UINT8";
    static unsignedComponentTypes: string[];
}

// @internal
export interface MetadataEntity extends RootProperty {
    class: string;
    properties?: {
        [key: string]: any;
    };
}

// @internal
export interface MetadataEntityModel {
    getPropertyValue(propertyId: string): any;
    getPropertyValueBySemantic(semantic: string): any;
}

// @internal
export class MetadataEntityModels {
    static computeSemanticToPropertyIdMapping(metadataClass: MetadataClass): {
        [key: string]: string;
    };
    static create(schema: Schema, entity: MetadataEntity): MetadataEntityModel;
    static createFromClass(metadataClass: MetadataClass, entityProperties: {
        [key: string]: any;
    }): DefaultMetadataEntityModel;
}

// @internal
export interface MetadataEnum extends RootProperty {
    description?: string;
    name?: string;
    values: EnumValue[];
    valueType?: string;
}

// @internal
export class MetadataError extends Error {
    constructor(message: string);
    // (undocumented)
    toString: () => string;
}

// @internal
export class MetadataTypes {
    static allTypes: string[];
    // (undocumented)
    static readonly BOOLEAN = "BOOLEAN";
    static componentCountForType(type: string): number;
    // (undocumented)
    static readonly ENUM = "ENUM";
    static isNumericType(type: string): boolean;
    // (undocumented)
    static readonly MAT2 = "MAT2";
    // (undocumented)
    static readonly MAT3 = "MAT3";
    // (undocumented)
    static readonly MAT4 = "MAT4";
    static numericTypes: string[];
    // (undocumented)
    static readonly SCALAR = "SCALAR";
    // (undocumented)
    static readonly STRING = "STRING";
    // (undocumented)
    static readonly VEC2 = "VEC2";
    // (undocumented)
    static readonly VEC3 = "VEC3";
    // (undocumented)
    static readonly VEC4 = "VEC4";
}

// @internal
export class MetadataUtilities {
    static computeBinaryEnumInfo(schema: Schema): BinaryEnumInfo;
    static obtainEnumValueNames(classProperty: ClassProperty, schema: Schema): string[];
}

// @internal
export class MetadataValues {
    static processValue(classProperty: ClassProperty, offsetOverride: any, scaleOverride: any, value: any): any;
}

// @internal
export class NumericBuffers {
    static getNumericArrayFromBuffer(buffer: Buffer, index: number, arrayLength: number, componentType: string): (number | bigint)[];
    static getNumericBufferAsArray(buffer: Buffer, componentType: string): any;
    static getNumericFromBuffer(buffer: Buffer, index: number, componentType: string): number | bigint;
}

// @internal
export class OctreeCoordinates implements TreeCoordinates {
    constructor(level: number, x: number, y: number, z: number);
    children(): Iterable<OctreeCoordinates>;
    descendants(maxLevelInclusive: number, depthFirst: boolean): Iterable<OctreeCoordinates>;
    get level(): number;
    parent(): OctreeCoordinates | null;
    toArray(): number[];
    toIndex(): number;
    toIndexInLevel(): number;
    // (undocumented)
    toString: () => string;
    // (undocumented)
    get x(): number;
    // (undocumented)
    get y(): number;
    // (undocumented)
    get z(): number;
}

// @internal
export class Octrees {
    static computeNumberOfNodesForLevels(levels: number): number;
    static coordinatesForLevel(level: number): Generator<OctreeCoordinates, void, unknown>;
    static isValid(c: OctreeCoordinates): boolean;
}

// @internal
export class Paths {
    static ensureDirectoryExists(directory: string): void;
    static hasExtension(fileName: string, ...extensions: string[]): boolean;
    static isDirectory(p: string): boolean;
    static join(...paths: string[]): string;
    static relativize(directory: string, fileName: string): string;
    static replaceExtension(fileName: string, newExtension: string): string;
    static resolve(...paths: string[]): string;
}

// @internal
export interface Properties extends RootProperty {
    maximum: number;
    minimum: number;
}

// @internal
export interface PropertyModel {
    getPropertyValue(index: number): any;
}

// @internal
export interface PropertyTable extends RootProperty {
    class: string;
    count: number;
    name?: string;
    properties?: {
        [key: string]: PropertyTableProperty;
    };
}

// @internal
export interface PropertyTableModel {
    getClassProperty(propertyId: string): ClassProperty | undefined;
    getCount(): number;
    getMetadataEntityModel(index: number): MetadataEntityModel;
    getPropertyModel(propertyId: string): PropertyModel | undefined;
    getPropertyNames(): string[];
    getPropertyTableProperty(propertyId: string): PropertyTableProperty | undefined;
}

// @internal
export interface PropertyTableProperty extends RootProperty {
    arrayOffsets?: number;
    arrayOffsetType?: string;
    max?: any;
    min?: any;
    offset?: any;
    scale?: any;
    stringOffsets?: number;
    stringOffsetType?: string;
    values: number;
}

// @internal
export class QuadtreeCoordinates implements TreeCoordinates {
    constructor(level: number, x: number, y: number);
    children(): Iterable<QuadtreeCoordinates>;
    descendants(maxLevelInclusive: number, depthFirst: boolean): Iterable<QuadtreeCoordinates>;
    get level(): number;
    parent(): QuadtreeCoordinates | null;
    toArray(): number[];
    toIndex(): number;
    toIndexInLevel(): number;
    // (undocumented)
    toString: () => string;
    // (undocumented)
    get x(): number;
    // (undocumented)
    get y(): number;
}

// @internal
export class Quadtrees {
    static computeNumberOfNodesForLevels(levels: number): number;
    static coordinatesForLevel(level: number): Generator<QuadtreeCoordinates, void, unknown>;
    static isValid(c: QuadtreeCoordinates): boolean;
}

// @internal
export interface ResourceResolver {
    derive(uri: string): ResourceResolver;
    resolveData(uri: string): Promise<Buffer | null>;
    resolveDataPartial(uri: string, maxBytes: number): Promise<Buffer | null>;
}

// @internal
export class ResourceResolvers {
    static createFileResourceResolver(directory: string): UnzippingResourceResolver;
}

// @internal
export interface RootProperty {
    // (undocumented)
    extensions?: {
        [key: string]: {
            [key: string]: any;
        };
    };
    // (undocumented)
    extras?: {
        [key: string]: any;
    };
}

// @internal
export interface Schema extends RootProperty {
    classes?: {
        [key: string]: MetadataClass;
    };
    description?: string;
    enums?: {
        [key: string]: MetadataEnum;
    };
    id: string;
    name?: string;
    version?: string;
}

// @internal
export interface Statistics extends RootProperty {
    classes?: {
        [key: string]: StatisticsClass;
    };
}

// @internal
export interface StatisticsClass extends RootProperty {
    count?: number;
    properties?: {
        [key: string]: StatisticsClassProperty;
    };
}

// @internal
export interface StatisticsClassProperty extends RootProperty {
    max?: any;
    mean?: any;
    median?: any;
    min?: any;
    occurrences?: {
        [key: string]: any;
    };
    standardDeviation?: any;
    sum?: any;
    variance?: any;
}

// @internal
export interface Subtree extends RootProperty {
    buffers?: BufferObject[];
    bufferViews?: BufferView[];
    childSubtreeAvailability: Availability;
    contentAvailability?: Availability[];
    contentMetadata?: number[];
    propertyTables?: PropertyTable[];
    subtreeMetadata?: MetadataEntity;
    tileAvailability: Availability;
    tileMetadata?: number;
}

// @internal
export interface SubtreeInfo {
    childSubtreeAvailabilityInfo: AvailabilityInfo;
    contentAvailabilityInfos: AvailabilityInfo[];
    tileAvailabilityInfo: AvailabilityInfo;
}

// @internal
export class SubtreeInfos {
    static create(binarySubtreeData: BinarySubtreeData, implicitTiling: TileImplicitTiling): SubtreeInfo;
    static createFromBuffer(input: Buffer, implicitTiling: TileImplicitTiling, resourceResolver: ResourceResolver): Promise<SubtreeInfo>;
    static createFromJson(subtree: Subtree, implicitTiling: TileImplicitTiling, resourceResolver: ResourceResolver): Promise<SubtreeInfo>;
}

// @internal
export interface SubtreeMetadataModel {
    contentIndexMappings: number[][];
    contentMetadataModels: PropertyTableModel[];
    schema: Schema;
    tileIndexMapping: number[] | undefined;
    tileMetadataModel: PropertyTableModel | undefined;
}

// @internal
export class SubtreeMetadataModels {
    static create(binarySubtreeData: BinarySubtreeData, subtreeInfo: SubtreeInfo, schema: Schema): SubtreeMetadataModel;
}

// @internal
export interface SubtreeModel {
    subtreeInfo: SubtreeInfo;
    subtreeMetadataModel: SubtreeMetadataModel | undefined;
}

// @internal
export class SubtreeModels {
    static resolve(implicitTiling: TileImplicitTiling, schema: Schema | undefined, resourceResolver: ResourceResolver, coordinates: TreeCoordinates): Promise<SubtreeModel>;
}

// @internal
export interface Subtrees extends RootProperty {
    uri: string;
}

// @internal
export class TemplateUris {
    static substituteOctree(templateUri: string, coordinates: OctreeCoordinates): string;
    static substituteOctreeInternal(templateUri: string, level: number, x: number, y: number, z: number): string;
    static substituteQuadtree(templateUri: string, coordinates: QuadtreeCoordinates): string;
    static substituteQuadtreeInternal(templateUri: string, level: number, x: number, y: number): string;
}

// @internal
export interface Tile extends RootProperty {
    boundingVolume: BoundingVolume;
    children?: Tile[];
    content?: Content;
    contents?: Content[];
    geometricError: number;
    implicitTiling?: TileImplicitTiling;
    metadata?: MetadataEntity;
    refine?: string;
    transform?: number[];
    viewerRequestVolume?: BoundingVolume;
}

// @internal
export interface TileImplicitTiling extends RootProperty {
    availableLevels: number;
    subdivisionScheme: string;
    subtreeLevels: number;
    subtrees: Subtrees;
}

// @internal
export interface Tileset extends RootProperty {
    asset: Asset;
    extensionsRequired?: string[];
    extensionsUsed?: string[];
    geometricError: number;
    groups?: Group[];
    metadata?: MetadataEntity;
    properties?: {
        [key: string]: Properties;
    };
    root: Tile;
    schema?: Schema;
    schemaUri?: string;
    statistics?: Statistics;
}

// @internal
export interface TilesetEntry {
    key: string;
    value: Buffer;
}

// @internal
export class TilesetError extends Error {
    constructor(message: string);
    // (undocumented)
    toString: () => string;
}

// @internal
export interface TilesetSource {
    close(): void;
    getKeys(): Iterable<string>;
    getValue(key: string): Buffer | undefined;
    open(fullInputName: string): void;
}

// @internal
export class TilesetSource3dtiles implements TilesetSource {
    constructor();
    close(): void;
    getKeys(): Iterable<string>;
    getValue(key: string): Buffer | undefined;
    open(fullInputName: string): void;
}

// @internal
export class TilesetSource3tz implements TilesetSource {
    constructor();
    close(): void;
    getKeys(): Iterable<string>;
    getValue(key: string): Buffer | undefined;
    // (undocumented)
    getZipIndex(): IndexEntry[] | undefined;
    open(fullInputName: string): void;
}

// @internal
export class TilesetSourceFs implements TilesetSource {
    constructor();
    close(): void;
    getKeys(): Iterable<string>;
    getValue(key: string): Buffer | undefined;
    open(fullInputName: string): void;
}

// @internal
export class TilesetSourceResourceResolver implements ResourceResolver {
    constructor(basePath: string, tilesetSource: TilesetSource);
    derive(uri: string): ResourceResolver;
    resolveData(uri: string): Promise<Buffer | null>;
    resolveDataPartial(uri: string, maxBytes: number): Promise<Buffer | null>;
}

// @internal
export class TilesetSources {
    static create(extension: string): TilesetSource | undefined;
    static createAndOpen(name: string): TilesetSource;
    static getEntries(tilesetSource: TilesetSource): Iterable<TilesetEntry>;
}

// @internal
export interface TilesetTarget {
    addEntry(key: string, content: Buffer): void;
    begin(fullOutputName: string, overwrite: boolean): void;
    end(): Promise<void>;
}

// @internal
export class TilesetTarget3dtiles implements TilesetTarget {
    constructor();
    addEntry(key: string, content: Buffer): void;
    begin(fullOutputName: string, overwrite: boolean): void;
    end(): Promise<void>;
}

// @internal
export class TilesetTarget3tz implements TilesetTarget {
    constructor();
    addEntry(key: string, content: Buffer): void;
    begin(fullOutputName: string, overwrite: boolean): void;
    end(): Promise<void>;
}

// @internal
export class TilesetTargetFs implements TilesetTarget {
    constructor();
    addEntry(key: string, content: Buffer): void;
    begin(fullOutputName: string, overwrite: boolean): void;
    end(): Promise<void>;
}

// @internal
export class TilesetTargets {
    static create(extension: string): TilesetTarget | undefined;
    static createAndBegin(name: string, overwrite: boolean): TilesetTarget;
    static putEntries(tilesetTarget: TilesetTarget, entries: Iterable<TilesetEntry>): void;
}

// @internal
export class TilesetTraverser {
    constructor(baseUri: string, resourceResolver: ResourceResolver, options?: TraversalOptions);
    traverse(tileset: Tileset, traversalCallback: TraversalCallback): Promise<void>;
    traverseWithSchema(tileset: Tileset, schema: Schema | undefined, traversalCallback: TraversalCallback): Promise<void>;
    traverseWithSchemaAt(tile: Tile, schema: Schema | undefined, traversalCallback: TraversalCallback): Promise<void>;
}

// @internal
export interface TraversalCallback {
    (traversedTile: TraversedTile): Promise<boolean>;
}

// @internal
export type TraversalOptions = {
    depthFirst?: boolean;
    traverseExternalTilesets?: boolean;
};

// @internal
export interface TraversedTile {
    asFinalTile(): Tile;
    asRawTile(): Tile;
    getChildren(): Promise<TraversedTile[]>;
    getFinalContents(): Content[];
    getParent(): TraversedTile | undefined;
    getRawContents(): Content[];
    getResourceResolver(): ResourceResolver;
    getSubtreeUri(): string | undefined;
    isImplicitTilesetRoot(): boolean;
    get level(): number;
    get path(): string;
}

// @internal
export interface TreeCoordinates {
    children(): Iterable<TreeCoordinates>;
    descendants(maxLevelInclusive: number, depthFirst: boolean): Iterable<TreeCoordinates>;
    get level(): number;
    parent(): TreeCoordinates | null;
    toArray(): number[];
    toIndex(): number;
    toIndexInLevel(): number;
}

// @internal
export class UnzippingResourceResolver implements ResourceResolver {
    constructor(delegate: ResourceResolver);
    derive(uri: string): ResourceResolver;
    resolveData(uri: string): Promise<Buffer | null>;
    resolveDataPartial(uri: string, maxBytes: number): Promise<Buffer | null>;
}

// @internal
export class Uris {
    static isAbsoluteUri(uri: string): boolean;
    static isDataUri(uri: string): boolean;
}

// (No @packageDocumentation comment for this package)

```
