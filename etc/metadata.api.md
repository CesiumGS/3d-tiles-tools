## API Report File for "@3d-tiles-tools/metadata"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { BinaryBufferData } from '@3d-tiles-tools/base';
import { BinaryBufferStructure } from '@3d-tiles-tools/base';
import { ClassProperty } from '@3d-tiles-tools/structure';
import { MetadataClass } from '@3d-tiles-tools/structure';
import { MetadataEntity } from '@3d-tiles-tools/structure';
import { MetadataEnum } from '@3d-tiles-tools/structure';
import { PropertyTable } from '@3d-tiles-tools/structure';
import { PropertyTableProperty } from '@3d-tiles-tools/structure';
import { Schema } from '@3d-tiles-tools/structure';

// @internal
export class ArrayBuffers {
    static fromBuffer(buffer: Buffer): ArrayBuffer;
}

// @internal
export class ArrayValues {
    static anyDeepGreaterThan(a: any, b: any): boolean;
    static anyDeepLessThan(a: any, b: any): boolean;
    static deepAdd(value: any, addend: any): any;
    static deepClone(value: any): any;
    static deepEquals(a: any, b: any): boolean;
    static deepMax(a: any, b: any): any;
    static deepMin(a: any, b: any): any;
    static deepMultiply(value: any, factor: any): any;
}

// @internal
export interface BinaryEnumInfo {
    enumValueNameValues: {
        [key: string]: {
            [key: string]: number;
        };
    };
    enumValueTypes: {
        [key: string]: string;
    };
    enumValueValueNames: {
        [key: string]: {
            [key: number]: string;
        };
    };
}

// @internal
export interface BinaryMetadata {
    binaryBufferData: BinaryBufferData;
    binaryBufferStructure: BinaryBufferStructure;
    binaryEnumInfo: BinaryEnumInfo;
    metadataClass: MetadataClass;
}

// @internal
export class BinaryPropertyModels {
    static computeSlice(index: number, offsetsBuffer: Buffer | undefined, offsetType: string, count: number | undefined): {
        offset: number;
        length: number;
    };
    static createPropertyModel(binaryPropertyTable: BinaryPropertyTable, propertyId: string): PropertyModel;
    static createPropertyModelInternal(propertyId: string, type: string, componentType: string | undefined, isArray: boolean, count: number | undefined, valuesBufferViewData: Buffer, arrayOffsetsBufferViewData: Buffer | undefined, arrayOffsetType: string, stringOffsetsBufferViewData: Buffer | undefined, stringOffsetType: string, enumValueType: string | undefined): PropertyModel;
}

// @internal
export interface BinaryPropertyTable {
    binaryMetadata: BinaryMetadata;
    propertyTable: PropertyTable;
}

// @internal
export class BinaryPropertyTableBuilder {
    addProperties(properties: {
        [key: string]: any[];
    }): this;
    addProperty(propertyName: string, propertyValues: any[]): this;
    build(): BinaryPropertyTable;
    static create(schema: Schema, propertyTableClass: string, propertyTableName: string): BinaryPropertyTableBuilder;
}

// @internal
export class BinaryPropertyTableModel implements PropertyTableModel {
    constructor(binaryPropertyTable: BinaryPropertyTable);
    getClassProperty(propertyId: string): ClassProperty | undefined;
    // (undocumented)
    getCount(): number;
    getMetadataEntityModel(index: number): MetadataEntityModel;
    getPropertyModel(propertyId: string): PropertyModel | undefined;
    // (undocumented)
    getPropertyNames(): string[];
    getPropertyTableProperty(propertyId: string): PropertyTableProperty | undefined;
}

// @internal
export class BinaryPropertyTables {
    static createBinaryPropertyTable(schema: Schema, className: string, propertyName: string, values: any, arrayOffsetType: string | undefined, stringOffsetType: string | undefined): BinaryPropertyTable;
    static createBinaryPropertyTableFromProperty(propertyName: string, classProperty: ClassProperty, values: any, arrayOffsetType: string | undefined, stringOffsetType: string | undefined, metadataEnum: MetadataEnum | undefined): BinaryPropertyTable;
    static createPropertyTableProperty(classProperty: ClassProperty, schema: Schema, values: any, arrayOffsetType: string | undefined, stringOffsetType: string | undefined, bufferViewsData: Buffer[]): PropertyTableProperty;
    static createSchemaFromClassProperty(propertyName: string, classProperty: ClassProperty, metadataEnum: MetadataEnum | undefined): Schema;
}

// @internal
export class BooleanArrayPropertyModel implements PropertyModel {
    constructor(valuesBuffer: Buffer, arrayOffsetsBuffer: Buffer | undefined, arrayOffsetType: string, count: number | undefined);
    getPropertyValue(index: number): boolean[];
}

// @internal
export class BooleanPropertyModel implements PropertyModel {
    constructor(valuesBuffer: Buffer);
    getPropertyValue(index: number): boolean;
}

// @internal
export class ClassProperties {
    static hasEffectivelyFloatingPointType(property: ClassProperty): boolean;
    static hasNumericType(property: ClassProperty): boolean;
}

// @internal
export class DefaultMetadataEntityModel implements MetadataEntityModel {
    constructor(metadataClass: MetadataClass, semanticToPropertyId: {
        [key: string]: string;
    }, json: any);
    getPropertyValue(propertyId: string): any;
    getPropertyValueBySemantic(semantic: string): any;
}

// @internal
export class DefaultPropertyModel implements PropertyModel {
    constructor(data: any[]);
    getPropertyValue(index: number): any;
}

// @internal
export class DefaultPropertyTableModel implements PropertyTableModel {
    constructor(numRows: number);
    addClassProperty(propertyId: string, classProperty: ClassProperty): void;
    addPropertyModel(propertyId: string, propertyModel: PropertyModel): void;
    getClassProperty(propertyId: string): ClassProperty | undefined;
    getCount(): number;
    getMetadataEntityModel(index: number): MetadataEntityModel;
    getPropertyModel(propertyId: string): PropertyModel | undefined;
    getPropertyNames(): string[];
    getPropertyTableProperty(propertyId: string): PropertyTableProperty | undefined;
}

// @internal
export class MetadataComponentTypes {
    static allComponentTypes: string[];
    static byteSizeForComponentType(componentType: string): number;
    // (undocumented)
    static readonly FLOAT32 = "FLOAT32";
    // (undocumented)
    static readonly FLOAT64 = "FLOAT64";
    // (undocumented)
    static readonly INT16 = "INT16";
    // (undocumented)
    static readonly INT32 = "INT32";
    // (undocumented)
    static readonly INT64 = "INT64";
    // (undocumented)
    static readonly INT8 = "INT8";
    static integerComponentTypes: string[];
    static isIntegerComponentType(componentType: string | undefined): boolean;
    static isUnsignedComponentType(componentType: string | undefined): boolean;
    // (undocumented)
    static normalize(value: number, componentType: string | undefined): number;
    // (undocumented)
    static readonly UINT16 = "UINT16";
    // (undocumented)
    static readonly UINT32 = "UINT32";
    // (undocumented)
    static readonly UINT64 = "UINT64";
    // (undocumented)
    static readonly UINT8 = "UINT8";
    static unsignedComponentTypes: string[];
}

// @internal
export interface MetadataEntityModel {
    getPropertyValue(propertyId: string): any;
    getPropertyValueBySemantic(semantic: string): any;
}

// @internal
export class MetadataEntityModels {
    static computeSemanticToPropertyIdMapping(metadataClass: MetadataClass): {
        [key: string]: string;
    };
    static create(schema: Schema, entity: MetadataEntity): MetadataEntityModel;
    static createFromClass(metadataClass: MetadataClass, metadataEnums: {
        [key: string]: MetadataEnum;
    }, entityProperties: {
        [key: string]: any;
    }): DefaultMetadataEntityModel;
}

// @internal
export class MetadataError extends Error {
    constructor(message: string);
    // (undocumented)
    toString: () => string;
}

// @internal
export class MetadataTypes {
    static allTypes: string[];
    // (undocumented)
    static readonly BOOLEAN = "BOOLEAN";
    static componentCountForType(type: string): number;
    // (undocumented)
    static readonly ENUM = "ENUM";
    static isNumericType(type: string): boolean;
    // (undocumented)
    static readonly MAT2 = "MAT2";
    // (undocumented)
    static readonly MAT3 = "MAT3";
    // (undocumented)
    static readonly MAT4 = "MAT4";
    static numericTypes: string[];
    // (undocumented)
    static readonly SCALAR = "SCALAR";
    // (undocumented)
    static readonly STRING = "STRING";
    // (undocumented)
    static readonly VEC2 = "VEC2";
    // (undocumented)
    static readonly VEC3 = "VEC3";
    // (undocumented)
    static readonly VEC4 = "VEC4";
}

// @internal
export class MetadataUtilities {
    static computeBinaryEnumInfo(schema: Schema): BinaryEnumInfo;
    static computeEnumValueType(schema: Schema, classProperty: ClassProperty): string | undefined;
    static computeMetadataEnumValueNameValues(metadataEnum: MetadataEnum): {
        [key: string]: number;
    };
    static computeMetadataEnumValueValueNames(metadataEnum: MetadataEnum): {
        [key: number]: string;
    };
    static obtainEnumValueNames(classProperty: ClassProperty, schema: Schema): string[];
}

// @internal
export class MetadataValues {
    static processNumericEnumValue(classProperty: ClassProperty, valueValueNames: {
        [key: number]: string;
    }, value: number | number[]): any;
    static processValue(classProperty: ClassProperty, offsetOverride: any, scaleOverride: any, value: any): any;
}

// @internal
export class NumericArrayPropertyModel implements PropertyModel {
    constructor(type: string, valuesBuffer: Buffer, componentType: string, arrayOffsetsBuffer: Buffer | undefined, arrayOffsetType: string, count: number | undefined);
    getPropertyValue(index: number): (number | bigint | (number | bigint)[])[];
}

// @internal
export class NumericBuffers {
    static getBooleanFromBuffer(buffer: Buffer, index: number): boolean;
    static getNumericArrayFromBuffer(buffer: Buffer, index: number, arrayLength: number, componentType: string): (number | bigint)[];
    static getNumericBufferAsArray(buffer: Buffer, componentType: string): any;
    static getNumericFromBuffer(buffer: Buffer, index: number, componentType: string): number | bigint;
}

// @internal
export class NumericPropertyModel implements PropertyModel {
    constructor(type: string, valuesBuffer: Buffer, componentType: string);
    getPropertyValue(index: number): number | bigint | (number | bigint)[];
}

// @internal
export interface PropertyModel {
    getPropertyValue(index: number): any;
}

// @internal
export class PropertyModels {
    static createIterable(propertyModel: PropertyModel, numElements: number): Iterable<any>;
    static createNumericArrayIterable(propertyModel: PropertyModel, numElements: number): Iterable<number[]>;
    static createNumericScalarIterable(propertyModel: PropertyModel, numElements: number): Iterable<number>;
}

// @internal
export interface PropertyTableModel {
    getClassProperty(propertyId: string): ClassProperty | undefined;
    getCount(): number;
    getMetadataEntityModel(index: number): MetadataEntityModel;
    getPropertyModel(propertyId: string): PropertyModel | undefined;
    getPropertyNames(): string[];
    getPropertyTableProperty(propertyId: string): PropertyTableProperty | undefined;
}

// @internal
export class PropertyTableModels {
    static createString(propertyTableModel: PropertyTableModel, maxRows?: number): string;
}

// @internal
export class StringArrayPropertyModel implements PropertyModel {
    constructor(valuesBuffer: Buffer, arrayOffsetsBuffer: Buffer | undefined, arrayOffsetType: string, stringOffsetsBuffer: Buffer, stringOffsetType: string, count: number | undefined);
    getPropertyValue(index: number): string[];
}

// @internal
export class StringPropertyModel implements PropertyModel {
    constructor(valuesBuffer: Buffer, stringOffsetsBuffer: Buffer, stringOffsetType: string);
    getPropertyValue(index: number): string;
}

// @internal
export class TableMetadataEntityModel implements MetadataEntityModel {
    constructor(propertyTableModel: PropertyTableModel, entityIndex: number, semanticToPropertyId: {
        [key: string]: string;
    }, enumValueValueNames: {
        [key: string]: {
            [key: number]: string;
        };
    });
    getPropertyValue(propertyId: string): any;
    getPropertyValueBySemantic(semantic: string): any;
}

// (No @packageDocumentation comment for this package)

```
