## API Report File for "@3d-tiles-tools/tilesets"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { Availability } from '@3d-tiles-tools/structure';
import { B3dmFeatureTable } from '@3d-tiles-tools/structure';
import { BatchTable } from '@3d-tiles-tools/structure';
import { BatchTableBinaryBodyReference } from '@3d-tiles-tools/structure';
import { BinaryBodyOffset } from '@3d-tiles-tools/structure';
import { BinaryBufferData } from '@3d-tiles-tools/base';
import { BinaryBufferStructure } from '@3d-tiles-tools/base';
import { Content } from '@3d-tiles-tools/structure';
import { Database } from 'better-sqlite3';
import { I3dmFeatureTable } from '@3d-tiles-tools/structure';
import { MetadataEntity } from '@3d-tiles-tools/structure';
import { OctreeCoordinates } from '@3d-tiles-tools/base';
import { PntsFeatureTable } from '@3d-tiles-tools/structure';
import { PropertyModel } from '@3d-tiles-tools/metadata';
import { PropertyTableModel } from '@3d-tiles-tools/metadata';
import { QuadtreeCoordinates } from '@3d-tiles-tools/base';
import { ResourceResolver } from '@3d-tiles-tools/base';
import { Schema } from '@3d-tiles-tools/structure';
import { Subtree } from '@3d-tiles-tools/structure';
import { Tile } from '@3d-tiles-tools/structure';
import { TileImplicitTiling } from '@3d-tiles-tools/structure';
import { Tileset } from '@3d-tiles-tools/structure';
import { TreeCoordinates } from '@3d-tiles-tools/base';

// @internal (undocumented)
export class ArchiveFunctions3tz {
    // (undocumented)
    static md5LessThan(md5hashA: Buffer, md5hashB: Buffer): boolean;
    // (undocumented)
    static readEntry(fd: number, zipIndex: IndexEntry[], path: string): {
        compression_method: number;
        data: Buffer;
    } | undefined;
    // (undocumented)
    static readFileName(fd: number, offset: number | bigint): string;
    // (undocumented)
    static readZipIndex(fd: number): IndexEntry[];
    // (undocumented)
    static readZipLocalFileHeader(fd: number, offset: number | bigint, path: string): ZipLocalFileHeader;
    // (undocumented)
    static zipIndexFind(zipIndex: IndexEntry[], searchHash: Buffer): number;
}

// @internal
export class AttributeCompression {
    static octDecode16(input: number[]): number[];
    static octDecode8(input: number[]): number[];
}

// @internal
export interface AvailabilityInfo {
    isAvailable(index: number): boolean;
    get length(): number;
}

// @internal
export class AvailabilityInfos {
    static createChildSubtree(availability: Availability, bufferViewDatas: Buffer[], implicitTiling: TileImplicitTiling): AvailabilityInfo;
    static createTileOrContent(availability: Availability, bufferViewDatas: Buffer[], implicitTiling: TileImplicitTiling): AvailabilityInfo;
}

// @internal
export class BatchTables {
    static obtainDracoProperties(batchTable: BatchTable): {
        [key: string]: number;
    };
    static obtainDracoPropertyNames(batchTable: BatchTable): string[];
}

// @internal
export interface BinarySubtreeData {
    binaryBufferData: BinaryBufferData;
    binaryBufferStructure: BinaryBufferStructure;
    subtree: Subtree;
}

// @internal
export class BinarySubtreeDataResolver {
    static resolveFromBuffer(input: Buffer, resourceResolver: ResourceResolver): Promise<BinarySubtreeData>;
    static resolveFromJson(subtree: Subtree, resourceResolver: ResourceResolver): Promise<BinarySubtreeData>;
    static resolveInternal(subtree: Subtree, binaryBuffer: Buffer | undefined, resourceResolver: ResourceResolver): Promise<BinarySubtreeData>;
}

// @internal
export class BufferAvailabilityInfo implements AvailabilityInfo {
    constructor(buffer: Buffer, length: number);
    isAvailable(index: number): boolean;
    get length(): number;
}

// @internal
export class Colors {
    static standardRGB565ToNormalizedLinearRGBA(input: number): number[];
    static standardRGBAToNormalizedLinearRGBA(input: number[]): number[];
    static standardRGBToNormalizedLinearRGBA(input: number[]): number[];
}

// @internal
export interface CompositeTileData {
    header: Header;
    innerTileBuffers: Buffer[];
}

// @internal
export class ConstantAvailabilityInfo implements AvailabilityInfo {
    constructor(available: boolean, length: number);
    isAvailable(index: number): boolean;
    get length(): number;
}

// @internal
export class Contents {
    static getUri(content: Content): string | undefined;
}

// @internal
export class ExplicitTraversedTile implements TraversedTile {
    constructor(tile: Tile, path: string, level: number, parent: TraversedTile | undefined, schema: Schema | undefined, resourceResolver: ResourceResolver);
    asFinalTile(): Tile;
    asRawTile(): Tile;
    static createRoot(root: Tile, schema: Schema | undefined, resourceResolver: ResourceResolver): TraversedTile;
    getChildren(): Promise<TraversedTile[]>;
    getFinalContents(): Content[];
    getImplicitTiling(): TileImplicitTiling | undefined;
    getMetadata(): MetadataEntity | undefined;
    getParent(): TraversedTile | undefined;
    getRawContents(): Content[];
    getResourceResolver(): ResourceResolver;
    getSubtreeUri(): string | undefined;
    isImplicitTilesetRoot(): boolean;
    get level(): number;
    get path(): string;
    toString: () => string;
}

// @internal
export class ExplicitTraversedTiles {
    static createTraversedChildren(implicitTiling: TileImplicitTiling, schema: Schema | undefined, parent: ExplicitTraversedTile, resourceResolver: ResourceResolver): Promise<TraversedTile[]>;
}

// @internal
export class Extensions {
    static addExtensionRequired(extensible: Extensible, extension: string): void;
    // Warning: (ae-forgotten-export) The symbol "Extensible" needs to be exported by the entry point index.d.ts
    static addExtensionUsed(extensible: Extensible, extension: string): void;
    // Warning: (ae-forgotten-export) The symbol "Extended" needs to be exported by the entry point index.d.ts
    static containsExtension(extended: Extended, extension: string): boolean;
    static removeExtension(extended: Extended, extension: string): void;
    static removeExtensionRequired(extensible: Extensible, extension: string): void;
    static removeExtensionUsed(extensible: Extensible, extension: string): void;
}

// @internal
export interface Header {
    gltfFormat?: number;
    magic: string;
    version: number;
}

// @internal
export class ImplicitTilingError extends Error {
    constructor(message: string);
    // (undocumented)
    toString: () => string;
}

// @internal
export class ImplicitTilings {
    static computeNumberOfNodesInLevel(implicitTiling: TileImplicitTiling, level: number): number;
    static computeNumberOfNodesPerSubtree(implicitTiling: TileImplicitTiling): number;
    static createRootCoordinates(implicitTiling: TileImplicitTiling): TreeCoordinates;
    static createString(coordinates: TreeCoordinates): string;
    static createSubtreeCoordinatesIterator(implicitTiling: TileImplicitTiling): Iterable<TreeCoordinates>;
    static globalizeCoordinates(implicitTiling: TileImplicitTiling, rootCoordinates: TreeCoordinates, coordinates: TreeCoordinates): TreeCoordinates;
    static substituteTemplateUri(subdivisionScheme: string, templateUri: string, coordinates: TreeCoordinates): string;
}

// @internal
export class ImplicitTraversedTile implements TraversedTile {
    constructor(implicitTiling: TileImplicitTiling, resourceResolver: ResourceResolver, root: TraversedTile, path: string, subtreeModel: SubtreeModel, globalLevel: number, globalCoordinate: TreeCoordinates, rootCoordinate: TreeCoordinates, localCoordinate: TreeCoordinates, parent: TraversedTile);
    asFinalTile(): Tile;
    asRawTile(): Tile;
    getChildren(): Promise<TraversedTile[]>;
    getFinalContents(): Content[];
    getGlobalCoordinate(): TreeCoordinates;
    getLocalCoordinate(): TreeCoordinates;
    getParent(): TraversedTile | undefined;
    getRawContents(): Content[];
    getResourceResolver(): ResourceResolver;
    getSubtreeUri(): string | undefined;
    isImplicitTilesetRoot(): boolean;
    get level(): number;
    get path(): string;
    toString: () => string;
}

// @internal
export class IndexBuilder {
    constructor();
    addEntry(key: string, size: number): void;
    createBuffer(): Buffer;
}

// @internal
export interface IndexBuilderEntry {
    key: string;
    offset: bigint;
}

// @internal
export interface IndexEntry {
    hash: Buffer;
    offset: bigint;
}

// @internal
export class MetadataSemanticOverrides {
    static applyExplicitContentMetadataSemanticOverrides(content: Content, schema: Schema): void;
    static applyExplicitTileMetadataSemanticOverrides(tile: Tile, schema: Schema): void;
    static applyImplicitContentMetadataSemanticOverrides(content: Content, contentSetIndex: number, tileIndex: number, subtreeMetadataModel: SubtreeMetadataModel): void;
    static applyImplicitTileMetadataSemanticOverrides(tile: Tile, tileIndex: number, subtreeMetadataModel: SubtreeMetadataModel): void;
}

// @internal
export interface SubtreeInfo {
    childSubtreeAvailabilityInfo: AvailabilityInfo;
    contentAvailabilityInfos: AvailabilityInfo[];
    tileAvailabilityInfo: AvailabilityInfo;
}

// @internal
export class SubtreeInfos {
    static create(binarySubtreeData: BinarySubtreeData, implicitTiling: TileImplicitTiling): SubtreeInfo;
    static createFromBuffer(input: Buffer, implicitTiling: TileImplicitTiling, resourceResolver: ResourceResolver): Promise<SubtreeInfo>;
    static createFromJson(subtree: Subtree, implicitTiling: TileImplicitTiling, resourceResolver: ResourceResolver): Promise<SubtreeInfo>;
}

// @internal
export interface SubtreeMetadataModel {
    contentIndexMappings: number[][];
    contentMetadataModels: PropertyTableModel[];
    schema: Schema;
    tileIndexMapping: number[] | undefined;
    tileMetadataModel: PropertyTableModel | undefined;
}

// @internal
export class SubtreeMetadataModels {
    static create(binarySubtreeData: BinarySubtreeData, subtreeInfo: SubtreeInfo, schema: Schema): SubtreeMetadataModel;
}

// @internal
export interface SubtreeModel {
    subtreeInfo: SubtreeInfo;
    subtreeMetadataModel: SubtreeMetadataModel | undefined;
}

// @internal
export class SubtreeModels {
    static resolve(implicitTiling: TileImplicitTiling, schema: Schema | undefined, resourceResolver: ResourceResolver, coordinates: TreeCoordinates): Promise<SubtreeModel>;
}

// @internal
export interface Table {
    binary: Buffer;
    json: any;
}

// @internal
export type TableStructure = {
    name: string;
    columns: {
        name: string;
        type: string;
    }[];
};

// @internal
export class TableStructureValidator {
    static validate(db: Database, tableStructure: TableStructure): string | undefined;
}

// @internal
export class TemplateUris {
    static substituteOctree(templateUri: string, coordinates: OctreeCoordinates): string;
    static substituteOctreeInternal(templateUri: string, level: number, x: number, y: number, z: number): string;
    static substituteQuadtree(templateUri: string, coordinates: QuadtreeCoordinates): string;
    static substituteQuadtreeInternal(templateUri: string, level: number, x: number, y: number): string;
}

// @internal
export interface TileData {
    batchTable: Table;
    featureTable: Table;
    header: Header;
    payload: Buffer;
}

// @internal
export interface TileDataBlockLayout {
    // (undocumented)
    end: number;
    // (undocumented)
    length: number;
    // (undocumented)
    start: number;
}

// @internal
export interface TileDataLayout {
    // (undocumented)
    batchTableBinary: TileDataBlockLayout;
    // (undocumented)
    batchTableJson: TileDataBlockLayout;
    // (undocumented)
    byteLength: number;
    // (undocumented)
    featureTableBinary: TileDataBlockLayout;
    // (undocumented)
    featureTableJson: TileDataBlockLayout;
    // (undocumented)
    headerLength: number;
    // (undocumented)
    legacyBatchLength: number | undefined;
    // (undocumented)
    magic: string;
    // (undocumented)
    payload: TileDataBlockLayout;
}

// @internal
export class TileDataLayouts {
    // (undocumented)
    static create(buffer: Buffer): TileDataLayout;
}

// @internal
export class TileFormatError extends Error {
    constructor(message: string);
    // (undocumented)
    toString: () => string;
}

// @internal
export class TileFormats {
    static createB3dmTileDataFromGlb(glbData: Buffer, featureTableJson: B3dmFeatureTable | undefined, featureTableBinary: Buffer | undefined, batchTableJson: BatchTable | undefined, batchTableBinary: Buffer | undefined): TileData;
    static createCompositeTileData(tileDatas: TileData[]): CompositeTileData;
    static createCompositeTileDataBuffer(compositeTileData: CompositeTileData): Buffer;
    static createDefaultB3dmTileDataFromGlb(glbData: Buffer): TileData;
    static createDefaultI3dmTileDataFromGlb(glbData: Buffer): TileData;
    static createI3dmTileDataFromGlb(glbData: Buffer, featureTableJson: I3dmFeatureTable | undefined, featureTableBinary: Buffer | undefined, batchTableJson: BatchTable | undefined, batchTableBinary: Buffer | undefined): TileData;
    static createTileDataBuffer(tileData: TileData): Buffer;
    static extractGlbBuffers(tileDataBuffer: Buffer, externalGlbResolver: (glbUri: string) => Promise<Buffer | undefined>): Promise<Buffer[]>;
    static extractGlbPayload(tileData: TileData): Buffer;
    static extractTileData(buffer: Buffer, tileDataLayout: TileDataLayout): {
        header: {
            magic: string;
            version: number;
            gltfFormat: number | undefined;
        };
        featureTable: {
            json: any;
            binary: Buffer;
        };
        batchTable: {
            json: any;
            binary: Buffer;
        };
        payload: Buffer;
    };
    static isComposite(buffer: Buffer): boolean;
    static obtainGlbPayload(tileData: TileData, externalGlbResolver: (glbUri: string) => Promise<Buffer | undefined>): Promise<Buffer | undefined>;
    static readCompositeTileData(buffer: Buffer): CompositeTileData;
    static readTileData(buffer: Buffer): TileData;
    static splitCmpt(tileDataBuffer: Buffer, recursive: boolean): Promise<Buffer[]>;
}

// @internal
export class Tiles {
    static getContents(tile: Tile): Content[];
    static getContentUris(tile: Tile): string[];
    static setContents(tile: Tile, contents: Content[]): void;
    static traverseExplicit(tile: Tile, callback: TileTraversalCallback): Promise<void>;
}

// @internal
export interface TilesetEntry {
    key: string;
    value: Buffer;
}

// @internal
export class TilesetError extends Error {
    constructor(message: string);
    // (undocumented)
    toString: () => string;
}

// @internal
export class TilesetInMemory implements TilesetSource, TilesetTarget {
    constructor();
    addEntry(key: string, content: Buffer): void;
    begin(fullOutputName: string, overwrite: boolean): void;
    close(): void;
    end(): Promise<void>;
    getKeys(): string[];
    getValue(key: string): Buffer | undefined;
    open(fullInputName: string): void;
}

// @internal
export class Tilesets {
    static areEqualPackages(tilesetPackageName0: string, tilesetPackageName1: string): boolean;
    static determineTilesetJsonFileName(tilesetDataName: string): string;
}

// @internal
export interface TilesetSource {
    close(): void;
    getKeys(): Iterable<string>;
    getValue(key: string): Buffer | undefined;
    open(fullInputName: string): void;
}

// @internal
export class TilesetSource3dtiles implements TilesetSource {
    constructor();
    close(): void;
    getKeys(): Iterable<string>;
    getValue(key: string): Buffer | undefined;
    open(fullInputName: string): void;
}

// @internal
export class TilesetSource3tz implements TilesetSource {
    constructor();
    close(): void;
    getKeys(): Iterable<string>;
    getValue(key: string): Buffer | undefined;
    // (undocumented)
    getZipIndex(): IndexEntry[] | undefined;
    open(fullInputName: string): void;
}

// @internal
export class TilesetSourceFs implements TilesetSource {
    constructor();
    close(): void;
    getKeys(): Iterable<string>;
    getValue(key: string): Buffer | undefined;
    open(fullInputName: string): void;
}

// @internal
export class TilesetSourceResourceResolver implements ResourceResolver {
    constructor(basePath: string, tilesetSource: TilesetSource);
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: The package "@3d-tiles-tools/tilesets" does not have an export "ResourceResolver"
    //
    // (undocumented)
    derive(uri: string): ResourceResolver;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: The package "@3d-tiles-tools/tilesets" does not have an export "ResourceResolver"
    //
    // (undocumented)
    resolveData(uri: string): Promise<Buffer | null>;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: The package "@3d-tiles-tools/tilesets" does not have an export "ResourceResolver"
    //
    // (undocumented)
    resolveDataPartial(uri: string, maxBytes: number): Promise<Buffer | null>;
}

// @internal
export class TilesetSources {
    static create(extension: string): TilesetSource | undefined;
    static createAndOpen(name: string): TilesetSource;
    static getEntries(tilesetSource: TilesetSource): Iterable<TilesetEntry>;
}

// @internal
export interface TilesetTarget {
    addEntry(key: string, content: Buffer): void;
    begin(fullOutputName: string, overwrite: boolean): void;
    end(): Promise<void>;
}

// @internal
export class TilesetTarget3dtiles implements TilesetTarget {
    constructor();
    addEntry(key: string, content: Buffer): void;
    begin(fullOutputName: string, overwrite: boolean): void;
    end(): Promise<void>;
}

// @internal
export class TilesetTarget3tz implements TilesetTarget {
    constructor();
    addEntry(key: string, content: Buffer): void;
    begin(fullOutputName: string, overwrite: boolean): void;
    end(): Promise<void>;
}

// @internal
export class TilesetTargetFs implements TilesetTarget {
    constructor();
    addEntry(key: string, content: Buffer): void;
    begin(fullOutputName: string, overwrite: boolean): void;
    end(): Promise<void>;
}

// @internal
export class TilesetTargets {
    static create(extension: string): TilesetTarget | undefined;
    static createAndBegin(name: string, overwrite: boolean): TilesetTarget;
    static putEntries(tilesetTarget: TilesetTarget, entries: Iterable<TilesetEntry>): void;
}

// @internal
export class TilesetTraverser {
    constructor(baseUri: string, resourceResolver: ResourceResolver, options?: TraversalOptions);
    traverse(tileset: Tileset, traversalCallback: TraversalCallback): Promise<void>;
    traverseWithSchema(tileset: Tileset, schema: Schema | undefined, traversalCallback: TraversalCallback): Promise<void>;
    traverseWithSchemaAt(tile: Tile, schema: Schema | undefined, traversalCallback: TraversalCallback): Promise<void>;
}

// @internal
export class TilesetTraversers {
    static createExternalTilesetRoots(baseUri: string, traversedTile: TraversedTile): Promise<TraversedTile[]>;
    static resolveSchema(tileset: Tileset, resourceResolver: ResourceResolver): Promise<Schema | undefined>;
}

// @internal
export class TileTableData {
    static convertLegacyComponentTypeToComponentType(legacyComponentType: string): "FLOAT32" | "INT8" | "UINT8" | "INT16" | "UINT16" | "INT32" | "UINT32" | "FLOAT64";
    static convertLegacyTypeToType(legacyType: string): "VEC3" | "SCALAR" | "VEC2" | "VEC4";
    static createBatchIdsFromBinary(binary: Buffer, byteOffset: number, legacyComponentType: string, numPoints: number): Iterable<number>;
    static createNumericArrayIterable(legacyType: string, legacyComponentType: string, binary: Buffer, byteOffset: number, numElements: number): Iterable<number[]>;
    static createNumericPropertyModel(legacyType: string, legacyComponentType: string, binary: Buffer, byteOffset: number): PropertyModel;
    static createNumericScalarIterable(legacyType: string, legacyComponentType: string, binary: Buffer, byteOffset: number, numElements: number): Iterable<number>;
    static createPositions(featureTable: PntsFeatureTable | I3dmFeatureTable, binary: Buffer, numPositions: number): Iterable<number[]>;
    static createPositionsFromBinary(binary: Buffer, byteOffset: number, numPositions: number): Iterable<number[]>;
    static isBatchTableBinaryBodyReference(p: any): p is BatchTableBinaryBodyReference;
    static obtainBatchIdComponentType(featureTable: PntsFeatureTable | I3dmFeatureTable): string | undefined;
    static obtainGlobalPosition(featureTable: PntsFeatureTable | I3dmFeatureTable, featureTableBinary: Buffer): [number, number, number] | undefined;
    static obtainNumberArray(binary: Buffer, property: number[] | BinaryBodyOffset, length: number, componentType: string): number[];
    static obtainQuantizationOffsetScale(featureTable: PntsFeatureTable | I3dmFeatureTable, featureTableBinary: Buffer): {
        offset: number[];
        scale: number[];
    } | undefined;
    static obtainRtcCenter(rtcCenter: BinaryBodyOffset | number[], binary: Buffer): [number, number, number];
}

// @internal
export class TileTableDataI3dm {
    static createBatchIds(featureTable: I3dmFeatureTable, binary: Buffer): Iterable<number> | undefined;
    static createInstanceMatrices(featureTable: I3dmFeatureTable, featureTableBinary: Buffer, numInstances: number): number[][];
    static createMatrices(translations3D: Iterable<number[]>, rotationQuaternions: Iterable<number[]> | undefined, scales3D: Iterable<number[]> | undefined, numInstances: number): number[][];
    static createNormalsUp(featureTable: I3dmFeatureTable, binary: Buffer, numElements: number): Iterable<number[]> | undefined;
    static createRotationQuaternions(featureTable: I3dmFeatureTable, featureTableBinary: Buffer, numInstances: number): Iterable<number[]> | undefined;
    static createScales3D(featureTable: I3dmFeatureTable, featureTableBinary: Buffer, numInstances: number): Iterable<number[]> | undefined;
    static createWorldPositions(featureTable: I3dmFeatureTable, featureTableBinary: Buffer, numInstances: number): Iterable<number[]>;
}

// @internal
export class TileTableDataPnts {
    static createBatchIds(featureTable: PntsFeatureTable, binary: Buffer): Iterable<number> | undefined;
    static createColorsStandardRGBAFromBinary(binary: Buffer, byteOffset: number, numElements: number): Iterable<number[]>;
    static createColorsStandardRGBFromBinary(binary: Buffer, byteOffset: number, numElements: number): Iterable<number[]>;
    static createGlobalNormalizedLinearColor(featureTable: PntsFeatureTable, binary: Buffer): [number, number, number, number] | undefined;
    static createNormalizedLinearColors(featureTable: PntsFeatureTable, binary: Buffer, numElements: number): Iterable<number[]> | undefined;
    static createNormals(featureTable: PntsFeatureTable, binary: Buffer, numElements: number): Iterable<number[]> | undefined;
    static createNormalsFromBinary(binary: Buffer, byteOffset: number, numElements: number): Iterable<number[]>;
}

// @internal
export type TileTraversalCallback = (tilePath: Tile[]) => Promise<boolean>;

// @internal
export interface TraversalCallback {
    (traversedTile: TraversedTile): Promise<boolean>;
}

// @internal
export type TraversalOptions = {
    depthFirst?: boolean;
    traverseExternalTilesets?: boolean;
};

// @internal
export interface TraversedTile {
    asFinalTile(): Tile;
    asRawTile(): Tile;
    getChildren(): Promise<TraversedTile[]>;
    getFinalContents(): Content[];
    getParent(): TraversedTile | undefined;
    getRawContents(): Content[];
    getResourceResolver(): ResourceResolver;
    getSubtreeUri(): string | undefined;
    isImplicitTilesetRoot(): boolean;
    get level(): number;
    get path(): string;
}

// @internal
export class VecMath {
    static add(a: number[], b: number[], result?: number[]): number[];
    static composeMatrixTRS(translation3D: number[], rotationQuaternion?: number[], scale3D?: number[]): number[];
    static computeEastNorthUpMatrix4(positionPacked: number[]): number[];
    static computeMean3D(points: Iterable<number[]>): number[];
    static computeRotationQuaternions(upVectors: number[][], rightVectors: number[][]): number[][];
    static createYupToZupPacked4(): number[];
    static createZupToYupPacked4(): number[];
    static decomposeMatrixTRS(matrix4Packed: number[]): {
        t: number[];
        r: number[];
        s: number[];
    };
    static matrix4ToQuaternion(matrix4Packed: number[]): number[];
    static multiplyAll4(matrices4Packed: number[][]): number[];
    static subtract(a: number[], b: number[], result?: number[]): number[];
}

// @internal (undocumented)
export interface ZipLocalFileHeader {
    // (undocumented)
    comp_size: number;
    // (undocumented)
    compression_method: number;
    // (undocumented)
    extra_size: number;
    // (undocumented)
    filename_size: number;
    // (undocumented)
    signature: number;
}

// @internal
export class ZipToPackage {
    static convert(inputFileName: string, inputTilesetJsonFileName: string, outputFileName: string, overwrite: boolean): Promise<void>;
}

// (No @packageDocumentation comment for this package)

```
