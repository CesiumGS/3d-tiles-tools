## API Report File for "@3d-tiles-tools/base"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { BufferObject } from '@3d-tiles-tools/structure';
import { BufferView } from '@3d-tiles-tools/structure';
import { Logger } from 'pino';
import { PathLike } from 'fs';

// @internal
export interface BinaryBufferData {
    buffersData: Buffer[];
    bufferViewsData: Buffer[];
}

// @internal
export class BinaryBufferDataResolver {
    static resolve(binaryBufferStructure: BinaryBufferStructure, binaryBuffer: Buffer | undefined, resourceResolver: ResourceResolver): Promise<BinaryBufferData>;
}

// @internal
export class BinaryBuffers {
    static createBinaryBufferStructure(binaryBufferData: BinaryBufferData, newBufferViewsData: Buffer[]): BinaryBufferStructure;
}

// @internal
export interface BinaryBufferStructure {
    // (undocumented)
    buffers: BufferObject[];
    // (undocumented)
    bufferViews: BufferView[];
}

// @internal
export class BinaryDataError extends Error {
    constructor(message: string);
    // (undocumented)
    toString: () => string;
}

// @internal
export class BufferedContentData implements ContentData {
    constructor(uri: string, data: Buffer | null);
    static create(uri: string): ContentData;
    exists(): Promise<boolean>;
    get extension(): string;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "data"
    //
    // (undocumented)
    getData(): Promise<Buffer | null>;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "magic"
    //
    // (undocumented)
    getMagic(): Promise<Buffer>;
    getParsedObject(): Promise<any>;
    get uri(): string;
}

// @internal
export class Buffers {
    static createBinaryString(buffer: Buffer): string;
    static fromTypedArray(array: Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array): Buffer;
    static getBufferPadded(buffer: Buffer, byteOffset?: number): Buffer;
    static getJson(buffer: Buffer): any;
    static getJsonBufferPadded(json: any, byteOffset?: number): Buffer;
    static getMagicBytes(buffer: Buffer, byteOffset: number, byteLength: number): Buffer;
    static getMagicString(buffer: Buffer, byteOffset?: number): string;
    static getUnicodeBOMDescription(buffer: Buffer): string | undefined;
    static gunzip(inputBuffer: Buffer): Buffer;
    static gzip(inputBuffer: Buffer): Buffer;
    static isGzipped(buffer: Buffer): boolean;
    static isProbablyJson(buffer: Buffer): boolean;
}

// @internal
export interface ContentData {
    exists(): Promise<boolean>;
    get extension(): string;
    getData(): Promise<Buffer | null>;
    getMagic(): Promise<Buffer>;
    getParsedObject(): Promise<any>;
    get uri(): string;
}

// @internal
export class ContentDataTypeChecks {
    static createCheck(includedContentDataTypes: (string | undefined)[] | undefined, excludedContentDataTypes: (string | undefined)[] | undefined): (contentData: ContentData) => Promise<boolean>;
    static createIncludedCheck(...contentDataTypes: string[]): (contentData: ContentData) => Promise<boolean>;
    static createTypeCheck(includedContentDataTypes: (string | undefined)[] | undefined, excludedContentDataTypes: (string | undefined)[] | undefined): (contentDataType: string | undefined) => boolean;
}

// @internal
export type ContentDataTypeEntry = {
    predicate: (contentData: ContentData) => Promise<boolean>;
    type: string;
};

// @internal
export class ContentDataTypeRegistry {
    static findContentDataType(contentData: ContentData): Promise<string | undefined>;
    static findType(uri: string, data: Buffer): Promise<string | undefined>;
}

// @internal
export class ContentDataTypes {
    // (undocumented)
    static readonly CONTENT_TYPE_3TZ = "CONTENT_TYPE_3TZ";
    // (undocumented)
    static readonly CONTENT_TYPE_B3DM = "CONTENT_TYPE_B3DM";
    // (undocumented)
    static readonly CONTENT_TYPE_CMPT = "CONTENT_TYPE_CMPT";
    // (undocumented)
    static readonly CONTENT_TYPE_GEOJSON = "CONTENT_TYPE_GEOJSON";
    // (undocumented)
    static readonly CONTENT_TYPE_GEOM = "CONTENT_TYPE_GEOM";
    // (undocumented)
    static readonly CONTENT_TYPE_GIF = "CONTENT_TYPE_GIF";
    // (undocumented)
    static readonly CONTENT_TYPE_GLB = "CONTENT_TYPE_GLB";
    // (undocumented)
    static readonly CONTENT_TYPE_GLTF = "CONTENT_TYPE_GLTF";
    // (undocumented)
    static readonly CONTENT_TYPE_I3DM = "CONTENT_TYPE_I3DM";
    // (undocumented)
    static readonly CONTENT_TYPE_JPEG = "CONTENT_TYPE_JPEG";
    // (undocumented)
    static readonly CONTENT_TYPE_PNG = "CONTENT_TYPE_PNG";
    // (undocumented)
    static readonly CONTENT_TYPE_PNTS = "CONTENT_TYPE_PNTS";
    // (undocumented)
    static readonly CONTENT_TYPE_SUBT = "CONTENT_TYPE_SUBT";
    // (undocumented)
    static readonly CONTENT_TYPE_TILESET = "CONTENT_TYPE_TILESET";
    // (undocumented)
    static readonly CONTENT_TYPE_VCTR = "CONTENT_TYPE_VCTR";
}

// @internal
export class DataError extends Error {
    constructor(message: string);
    // (undocumented)
    toString: () => string;
}

// @internal
export function defaultValue<T>(a: T | undefined, b: T): T;

// @internal
export function defined<T>(value: T): value is NonNullable<T>;

// @internal
export class DeveloperError extends Error {
    constructor(message: string);
    // (undocumented)
    toString: () => string;
}

// @internal
export class FileResourceResolver implements ResourceResolver {
    constructor(basePath: string);
    derive(uri: string): ResourceResolver;
    resolveData(uri: string): Promise<Buffer | null>;
    resolveDataPartial(uri: string, maxBytes: number): Promise<Buffer | null>;
}

// @internal
export class Iterables {
    static filter<T>(iterable: Iterable<T>, include: (element: T) => boolean): Iterable<T>;
    static filterWithIndex<T>(iterable: Iterable<T>, include: (element: T, index: number) => boolean): Iterable<T>;
    static flatten<T>(iterable: Iterable<T[]>): Iterable<T>;
    static map<S, T>(iterable: Iterable<S>, mapper: (element: S) => T): Iterable<T>;
    static overFiles(directory: string | PathLike, recurse: boolean): Iterable<string>;
    static segmentize<T>(iterable: Iterable<T>, segmentSize: number): Iterable<T[]>;
}

// @internal
export class LazyContentData implements ContentData {
    constructor(uri: string, resourceResolver: ResourceResolver);
    exists(): Promise<boolean>;
    get extension(): string;
    getData(): Promise<Buffer | null>;
    getMagic(): Promise<Buffer>;
    getParsedObject(): Promise<any>;
    get uri(): string;
}

// @internal
export class Loggers {
    static get(loggerName?: string): Logger;
    static initDefaultLogger(prettyPrint?: boolean): void;
    static setLevel(level: string): void;
}

// @internal
export class MortonOrder {
    static encode2D(x: number, y: number): number;
    static encode3D(x: number, y: number, z: number): number;
}

// @internal
export class OctreeCoordinates implements TreeCoordinates {
    constructor(level: number, x: number, y: number, z: number);
    children(): Iterable<OctreeCoordinates>;
    descendants(maxLevelInclusive: number, depthFirst: boolean): Iterable<OctreeCoordinates>;
    get level(): number;
    parent(): OctreeCoordinates | null;
    toArray(): number[];
    toIndex(): number;
    toIndexInLevel(): number;
    // (undocumented)
    toString: () => string;
    // (undocumented)
    get x(): number;
    // (undocumented)
    get y(): number;
    // (undocumented)
    get z(): number;
}

// @internal
export class Octrees {
    static computeNumberOfNodesForLevels(levels: number): number;
    static coordinatesForLevel(level: number): Generator<OctreeCoordinates, void, unknown>;
    static isValid(c: OctreeCoordinates): boolean;
}

// @internal
export class Paths {
    static ensureDirectoryExists(directory: string): void;
    static hasExtension(fileName: string, ...extensions: string[]): boolean;
    static isDirectory(p: string): boolean;
    static join(...paths: string[]): string;
    static relativize(directory: string, fileName: string): string;
    static replaceExtension(fileName: string, newExtension: string): string;
    static resolve(...paths: string[]): string;
}

// @internal
export class QuadtreeCoordinates implements TreeCoordinates {
    constructor(level: number, x: number, y: number);
    children(): Iterable<QuadtreeCoordinates>;
    descendants(maxLevelInclusive: number, depthFirst: boolean): Iterable<QuadtreeCoordinates>;
    get level(): number;
    parent(): QuadtreeCoordinates | null;
    toArray(): number[];
    toIndex(): number;
    toIndexInLevel(): number;
    // (undocumented)
    toString: () => string;
    // (undocumented)
    get x(): number;
    // (undocumented)
    get y(): number;
}

// @internal
export class Quadtrees {
    static computeNumberOfNodesForLevels(levels: number): number;
    static coordinatesForLevel(level: number): Generator<QuadtreeCoordinates, void, unknown>;
    static isValid(c: QuadtreeCoordinates): boolean;
}

// @internal
export interface ResourceResolver {
    derive(uri: string): ResourceResolver;
    resolveData(uri: string): Promise<Buffer | null>;
    resolveDataPartial(uri: string, maxBytes: number): Promise<Buffer | null>;
}

// @internal
export class ResourceResolvers {
    static createFileResourceResolver(directory: string): UnzippingResourceResolver;
}

// @internal
export interface TreeCoordinates {
    children(): Iterable<TreeCoordinates>;
    descendants(maxLevelInclusive: number, depthFirst: boolean): Iterable<TreeCoordinates>;
    get level(): number;
    parent(): TreeCoordinates | null;
    toArray(): number[];
    toIndex(): number;
    toIndexInLevel(): number;
}

// @internal
export class UnzippingResourceResolver implements ResourceResolver {
    constructor(delegate: ResourceResolver);
    derive(uri: string): ResourceResolver;
    resolveData(uri: string): Promise<Buffer | null>;
    resolveDataPartial(uri: string, maxBytes: number): Promise<Buffer | null>;
}

// @internal
export class Uris {
    static isAbsoluteUri(uri: string): boolean;
    static isDataUri(uri: string): boolean;
}

// (No @packageDocumentation comment for this package)

```
